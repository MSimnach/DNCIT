---
title: "Example: Pediatric ultrasonic images and electronic health records"
output: html_document
bibliography: "`r fs::path_package('references.bib', package='DNCIT')`" 
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

We apply the deep nonparametric conditional independence test (DNCIT) to pediatric ultrasonic images and electronic health records from the dataset in @Marcinkevics2023. This will illustrate an intermediate example to medical images and showcase potential challenges as well as research questions. 

The DNCIT tests for conditional associations between an image and a scalar outcome, given a vector-valued confounder. Thereby, different research questions can be addressed, with some examples being:

* Does the image contain additional information about the diagnosis, given electronic health records (EHRs)? 
* Is a specific EHR a potential confounder of the image, given other EHRs? 

In general, the DNCIT is developed for data consisting of $n$ i.i.d. copies of an image $X$, a scalar $Y$ and, potentially, a vector-valued confounder $Z$. The main challenge to apply the `DNCIT()` function is to input the data in the correct format, which is especially important for images. There are two important cases between which we differentiate: 

* Feature representations of the observed images are already available should be used in the test.
* The raw images are available and feature representations should be computed by a default embedding map of the package.

We discuss both scenarios separately in the following two sections, targeting the research questions above. Our dataset consists of a subset of the 572 pediatric ultrasonic images and tabular electronic health records. Additionally, we obtained preprocessed feature representations of the images.

```{r setup}
library(DNCIT)
if (requireNamespace("fs")){
  library(fs)
}else{
  install.packages('fs')
  library(fs)
}
```

## DNCIT applied to available feature representations

This case expects your data to consist of a metadata file with all the tabular data and a file with the feature representations. 

### Preprocessing 

In our example, the original images were preprocessed in python and the resulting feature representations are saved as a numpy array in a .npz. This format can be automatically loaded and processed by the function `DNCIT()` Moreover, the tabular data is saved as a python dictionary, which can be loaded into R as a list:


```{r meta data}
pediatric_data_path <- fs::path_package("extdata/example_pediatric_patients", package = "DNCIT")
meta_data_path <- paste(pediatric_data_path, 'app_data', sep='/')
meta_data_dict <- readLines(meta_data_path)
json <- reticulate::import('json')
meta_data <- json$loads(meta_data_dict)
head(meta_data,1)
```

So far, the tabular data consists for each subject (here subject with id 61) of the file names of the images in [[1]], the diagnosis of the patient in [[2]], tabular data in [[3]] and [[4]]. The tabular data in [[3]] consists of the features: 
```{r, echo=FALSE}
EHRs <- c('Age', 'Sex', 'Height', 'Weight', 'BMI', 'Alvarado_Score', 'Paedriatic_Appendicitis_Score',
'Peritonitis', 'Migratory_Pain', 'Lower_Right_Abd_Pain', 'Contralateral_Rebound_Tenderness', 'Coughing_Pain', 'Psoas_Sign', 'Nausea', 'Loss_of_Appetite', 'Body_Temperature', 'Dysuria', 'Stool', 'WBC_Count', 'Neutrophil_Percentage', 'CRP', 'Ketones_in_Urine', 'RBC_in_Urine',                'WBC_in_Urine', 'Appendix_on_US', 'Appendix_Diameter', 'Free_Fluids',  'Appendix_Wall_Layers', 'Target_Sign', 'Perfusion', 'Perforation', 
'Surrounding_Tissue_Reaction', 'Pathological_Lymph_Nodes', 'Bowel_Wall_Thickening', 'Ileus', 'Coprostasis', 'Meteorism', 'Enteritis', 'Appendicular_Abscess', 'Conglomerate_of_Bowel_Loops', 'Gynecological_Findings')
EHRs
```

First, we are interested in research question one, i.e. does the image contain additional information about the diagnosis, given all EHRs? Therefore, the conditioning variable $Z$ consists of all EHRs while the diagnosis $Y$ is the scalar outcome. The function `DNCIT()` requires both inputs to be given as matrix:

```{r construct Z and Y}
Y <- matrix(NA, nrow = length(meta_data), ncol = 1, dimnames = list(names(meta_data),NULL))
for (id in names(meta_data)){
  Y[id,] <- meta_data[id][[id]][[2]]
}
p <- length(meta_data$'61'[[3]])
Z <- matrix(NA, nrow = length(meta_data), ncol = p, dimnames = list(names(meta_data),EHRs))
for (id in names(meta_data)){
  Z[id,] <- meta_data[id][[id]][[3]]
}
print(head(Y,5))
head(Z,5)
```

The ids of the subjects are expected as row names in $Y$ and $Z$. Thereby, we can match them with the given feature representations in $X$. This is done automatically in the `DNCIT()` function for feature representations loaded from a .npz file. For the feature representations, the only thing that has to be provided is the directory of the .npz file.

```{r feature representation data}
X <- paste(pediatric_data_path, 'feature_representations/', sep='/')
```

### Information between image and diagnosis given all EHRs

To test if the ultrasonic image contains additional information for the diagnosis after accounting for all information available in the EHRs, we test for conditional dependence between the images and the diagnosis given the EHRs with `DNCIT()`applied to $X$, $Y$ and $Z$. The function loads the feature representations, matches the ids of tabular data and feature representations and applies a CIT of our choice, with the default being the RCoT [@strobl2019approximate]. The parameters to load the feature representations are given in a list [embedding_map_with_parameters], where we specify that we have already derived feature representations in embedding_map_with_parameters['embedding_map']='feature_representations' and the method to load them in embedding_map_with_parameters['data_loader']='npz'. Furthermore, we specify the CIT and its parameters in [cit_with_parameters], e.g. by cit_with_parameters['cit']='RCOT' and cit_with_parameters['seed']=123. We compare here all implemented CITs:

```{r DNCIT applied to feature representations}
embedding_map_with_parameters <- list(embedding_map = 'feature_representations', data_loader = 'npz')
#results <- matrix(NA, nrow=3, ncol=5, dimnames = list(c('Test Statistic', 'P-Value', 'Runtime'), c('RCOT', 'cpt_kpc', 'cmiknn', 'fcit', 'gcm')))
#RCoT
cit_with_parameters <- list(cit = 'RCOT', params_cit = list(seed=12))
res <- DNCIT(X, Y, Z, embedding_map_with_parameters = embedding_map_with_parameters, cit_with_parameters = cit_with_parameters)
print(res)
#results[, 'RCOT'] <- c(res$Sta, res$p, res$runtime)
#cpt_kpc
#cit_with_parameters <- list(cit = 'cpt_kpc', params_cit = list(k=kernlab::rbfdot(1/(2 * stats::median(stats::dist(Y))^2)),  Knn=10, model.formula.YZ='V1~V2+V3'))
#res <- DNCIT(X, Y, Z, embedding_map_with_parameters = embedding_map_with_parameters, cit_with_parameters = cit_with_parameters)
#results[, 'cpt_kpc'] <- c(res$Sta, res$p, res$runtime)
#cmiknn
#cit_with_parameters <- list(cit = 'cmiknn', params_cit = list(knn=0.2))
#res <- DNCIT(X, Y, Z, embedding_map_with_parameters = embedding_map_with_parameters, cit_with_parameters = cit_with_parameters)
#results[, 'cmiknn'] <- c(res$Sta, res$p, res$runtime)
#fcit
#cit_with_parameters <- list(cit = 'fcit')
#res <- DNCIT(X, Y, Z, embedding_map_with_parameters = embedding_map_with_parameters, cit_with_parameters = cit_with_parameters)
#results[, 'fcit'] <- c(res$Stat, res$p, res$runtime)
#gcm
#cit_with_parameters <- list(cit = 'gcm')
#res <- DNCIT(X, Y, Z, embedding_map_with_parameters = embedding_map_with_parameters, cit_with_parameters = cit_with_parameters)
#results[, 'gcm'] <- c(res$Sta, res$p, res$runtime)
```

The `DNCIT()` function outputs the test statistic, p-value and runtime of the (nonparametric) CIT applied to the feature representations. Usually, we would choose a suitable (nonparametric) CIT before the application of the DNCIT, depending on the sample size, dimension of the feature representations and confounder and the computational costs. 

The results imply that the image does not contain significant additional information about the diagnosis, given all EHRs. 

### Information between image and diagnosis given non-image-derived EHRs

This can have many reasons, one being that many EHRs such as the Appendix_Diameter in $Z$ are derived through experts from the image. Thus, they can be seen as mediator, taking away the relevant information within the image for the diagnosis. We want to check for this and run the CITs in a next step only on the image and non-image-derived EHRs: 

```{r Z without image-derived EHRs}
Z_others <- c('Age', 'Sex', 'Height', 'Weight', 'BMI', 'Length_of_Stay')
Z_scores <- c('Alvarado_Score', 'Paedriatic_Appendicitis_Score')
Z_clinical <- c('Peritonitis', 'Migratory_Pain', 'Lower_Right_Abd_Pain', 'Contralateral_Rebound_Tenderness', 'Ipsilateral_Rebound_Tenderness', 'Coughing_Pain', 'Psoas_Sign', 'Nausea', 'Loss_of_Appetite', 'Body_Temperature', 'Dysuria', 'Stool')
Z_lab <- c('WBC_Count', 'Neutrophil_Percentage', 'CRP', 'Ketones_in_Urine', 'RBC_in_Urine', 'WBC_in_Urine') 
Z_ultrasound <- c('Appendix_on_US', 'Appendix_Diameter', 'Free_Fluids',  'Appendix_Wall_Layers', 'Target_Sign', 'Perfusion', 'Perforation', 'Surrounding_Tissue_Reaction', 'Pathological_Lymph_Nodes', 'Bowel_Wall_Thickening', 'Ileus', 'Coprostasis', 'Meteorism', 'Enteritis', 'Appendicular_Abscess', 'Conglomerate_of_Bowel_Loops', 'Gynecological_Findings')
Z_non_ultrasound <- c(Z_lab[Z_lab %in% EHRs], Z_clinical[Z_clinical %in% EHRs], Z_scores[Z_scores %in% EHRs], Z_others[Z_others %in% EHRs])
Z_non_US <- Z[, Z_non_ultrasound, drop=FALSE]
Z_US <- Z[, Z_ultrasound[Z_ultrasound %in% EHRs], drop=FALSE]
Z_demo <- Z[, Z_others[Z_others %in% EHRs], drop=FALSE]
Z_age <- Z[, 'Age', drop=FALSE]
Z_sex <- Z[, 'Sex', drop=FALSE]

#RCoT
seeds=1:20
res <- rep(1, 20)
for(seed in seeds){
  cit_with_parameters <- list(cit = 'RCOT', params_cit = list(seed=seed))
  res[seed] <- DNCIT(X__, Y, Z=Z_non_US, embedding_map_with_parameters = embedding_map_with_parameters, cit_with_parameters = cit_with_parameters)$p
}
median(res)
```

### Potential confounder of the image

Next, we are interested in a somewhat different question. Often, it is advantageous to include less confounder for a CIT w.r.t. power, type 1 error and runtime. However, if relevant confounder, i.e. variables with causal effects on image and diagnosis, are not included, the CIT might reject the null hypothesis of conditional independence although the only association between image and diagnosis is through the confounder. 

## DNCITs applied directly to images

```{r image data}
img_path <- paste(pediatric_data_path, 'ultrasonic_images/', sep='/')
img_files <- list()
for(id in names(meta_data)){
  img_files[id] <- paste0(img_path, meta_data[id][[id]][[1]][1])
}
print(img_files[1:5])

```

## References
